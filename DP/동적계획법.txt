<동적 계획법> -> 알고리즘이 아닌 접근 방식 중 하나!

☞ 점화식만 잘 세워도 DP를 풀 수 있다.
-  전체 문제를 작은 문제로 단순화한 다음 점화식으로 만들어 재귀적인 구조를 활용해서 전체 문제를 해결하는 방식
1. 전체 문제를 작은 문제로 단순화한다. -> 부분 문제를 정의한다.
2. 재귀적인 구조를 활용할 수 있는 점화식을 만든다. -> 점화식을 만든다.
3. 작은 문제를 해결한 방법으로 전체 문제를 해결한다. -> 문제를 해결한다.

- 동적 계획법에서 각 문제는 한 번만 풀어야 한다.
방문했던 곳 혹은 중복되는 부분 문제를 여러번 풀지 않도록 '메모이제이션' 필요 

☞ 메모이제이션(memoization) 
: 재귀함수의 호출을 줄이기 위해서! 안 그러면 메모리 초과현상 발생
: 쉽게 말하면 계산한 부분은 배열에 표시를 하면서 가려가면서 재귀 호출
: 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 
동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술.
EX) 2의 n제곱 -> n의 시간복잡도로 줄임. 메모이제이션이 DP의 핵심임. 

☞ 구현 방식
1. Top-down : 큰 문제를 작은 문제로 쪼개면서 푼다. ☞'재귀'로 구현
2. Bottom-up : 작은 문제부터 차례대로 푼다. 즉 '점화식'을 세운 후 ☞ '반복문'으로 구현

예시 : https://kgh940525.tistory.com/entry/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EB%B0%B1%EC%A4%80-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-1463-1%EB%A1%9C-%EB%A7%8C%EB%93%A4%EA%B8%B0TopDownBottomUp-C

출처1: https://medium.com/@wooder2050/%EB%8F%99%EC%A0%81%EA%B3%84%ED%9A%8D%EB%B2%95-dynamic-programming-%EC%A0%95%EB%A6%AC-58e1dbcb80a0
출처2: https://velog.io/@polynomeer/%EB%8F%99%EC%A0%81-%EA%B3%84%ED%9A%8D%EB%B2%95Dynamic-Programming


