속도: O(n^2) -> 선택 정렬, 삽입정렬, 버블정렬 

<선택정렬>
- 제일 작은 값(min)을 맨 앞(i=0)에 위치시키기
- 결과적으로 맨 앞부터 정렬됨
- i = 1 부터 제일 작은 값을 i=1 위치에 위치시키기

<삽입정렬>
- 현재 인덱스 앞에  (정렬된)숫자들 사이에 현재 인덱스의 값을 알맞은 위치에 삽입시킴
- i = j 일 때,  j값과 j-1 비교 (j--) -> for문 돌음 거꾸로 
- 결과적으로 맨 앞부터 정렬됨. 

<버블정렬>
- 앞에서부터 양옆에 있는 것 비교 -> 결국에 맨 뒤에 가장 큰 수가 위치하게 됨 
- 결과적으로 맨 뒤부터 정렬됨.
- 비교시 주의! 
  i=0 -> j = 0~10 
  i=1 -> j = 0~9
  i=2 -> j= 0~8


속도 : O(nlogn) -> 합병정렬, 퀵정렬, 힙정렬
-> 세상에서 제일 빠른 정렬, 가장 빠른 정렬
→ O(n^2)이 1만 개의 데이터를 가지고 1억번 비교할 때 10만번만 비교해도 됨


<합병정렬>
- 배열을 절반으로 나누어 각각을 정렬한 후, 합친다. -> 이 과정이 재귀적으로 왼쪽, 오른쪽 반복됨
- 합칠때는 각 정렬된 왼쪽, 오른쪽 배열 중에 가장 앞에 있는 값 즉, 가장 작은값끼리 비교하여 정렬한다. 

함수 정의 : arr의 start부터 end까지 반으로 나누어 정렬해서 합병하는 함수


* 재귀 함수 디자인의 과정
1. 작성하려는 함수의 역할을 말로 명확하게 정의한다. 
2. 함수의 기저조건에서 제대로 동작하게 작성한다.
3. 함수가 제대로 동작한다고 가정하고 함수를 완성한다. 
4. 함수를 완성한 후, 기저조건으로 수렴함을 보인다. 


<퀵 정렬>
- 원소를 하나 정해서(pivot), 해당 원소보다 작은 수들과 큰 수들로 나눈다.
- 함수 정의 : arr의 s부터 e번째 값까지 정렬하는 함수

1. pivot을 정한다. 
2. 작거나 같은 값과 큰 값을 분류한다. 
3. 각각을 퀵정렬한다. 


※ 하지만 피봇이 정확히 배열의 중앙값일 경우 O(n logN) 걸림. 
→ 피봇을 어떻게 중앙값으로 잡는지에 대한 알고리즘 따로 있음. 
※ 피봇을 어떻게 정하느냐에 따라 최악의 경우 O(n^2) 걸림. 





