1. 연결요소 개수
: 그래프 중에는 여러 개로 나누어져 있을 수도 있다. 
위 그림을 보고 두 개의 그래프라고 볼 수도 있지만, 
하나의 그래프에 두 개의 연결 요소를 가진다고 볼 수도 있다. 
나누어진 각각의 그래프를 연결 요소라고 한다. 
-> 요약하자면 정점들의 집합의 개수 

출처: https://velog.io/@polynomeer/%EC%97%B0%EA%B2%B0-%EC%9A%94%EC%86%8CConnected-Component 


2. 그래프를 코드로 표현하는 방법
① 이차원 배열을 사용하는 방법과
② 연결 리스트를 사용하는 방법

출처: https://www.zerocho.com/category/Algorithm/post/584b9033580277001862f16c

- 무방향 그래프 vs 방향 있는 그래프 
☞ 무방향 그래프일 경우 양쪽 정점을 연결해준다. 

출처: https://www.zerocho.com/category/Algorithm/post/584b9033580277001862f16c

<그래프에서의 최소비용 문제>

(1) MST(최소 신장 트리) : 최소비용이 드는 트리를 찾는 문제  
☞ 최소 신장 트리? 간선의 가중치 합이 최소인 '신장트리'(사이클x, n개의 정점을 n-1개의 간선으로 연결)
☞ 그래프에서 최소 비용을 구하는 문제에서 사용함. 
1-①. 크루스칼 알고리즘 -> union-find 알고리즘 사용됨.  
https://chosh95.tistory.com/111?category=835072 
1-②. 프림 알고리즘 
=> 2가지 다 '탐욕법' 접근 방법임.
참고: http://naver.me/5Rck2LNG

(2) 최단거리: 출발지부터 목적지까지 최소비용이 드는 경로를 찾는 문제 

2-①. 플로이드 와샬 알고리즘 : N to N 모든 시작점.
[원리] 
- 거쳐가는 정점!을 바탕으로 모든 노드에서 모든 노드로 가는 최소 비용으로 갱신하는 것.
- a → b, b → c 로 가는 비용이  a → c로 가는 비용보다 작을 경우 갱신
[구현방법]
- 3중 for문으로 구현
참고: https://mungto.tistory.com/58 (동빈나 강의 포함.)

2-②. 다익스트라 알고리즘 : 1 to N 단일 시작점.
☞ 구현방법1 : 최소비용을 찾을 때, 선형탐색 O(n^2)
☞ 구현방법2 : 최소비용을 찾을 때, 힙구조 이용 O(nlogN)

선형탐색은 정점의 개수는 많지만, 간선의 개수가 적을 때 매우 비효율적.
따라서 힙구조를 이용한 '방법2'를 사용하자!

2-③. 벨만포드 알고리즘 : 
※음의 가중치를 허용하는 단일시작점 최단경로 '벨만포드' 알고리즘도 있음.